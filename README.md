DataProvider необходимо описывать через интерфейс согласно принципу инверсии зависимостей.
В этом интерфейсе как раз и необходимо определить метод get.
Что касается самого метода get, то нигде не описано какой именно массив на входе: это key=>value, либо данные хранятся с доступом по целочисленному индексу,
либо как-то еще? т.е. формат хранения нигде не описан и без работающих примеров невозможно понять что передавать в метод.
В конструкторе DataProvider не указаны типы данных ни в параметрах, ни в phpdoc (хотя судя по сигнатуре get код написан для php 7.x)
Более логично хранить данные для подключения в отдельном объекте и передавать его в конструктор DataProvider.

Если у нас используется php 7.x (код не будет выполняться на версиях ниже), то почему бы не использовать strict_types?

Теперь что касается DecoratorManager...

Лично мне название класса не говорит ни о чем (название класса должно показывать зачем вообще нужна отдельная сущность).
Еще одна странность: не смотря на Decorator в названии, класс не работает как декоратор (для декоратора логична передача расширяемого экземпляра через конструктор, а в примере
расширение логики метода get выполнено через наследование).
Свойства класса $cache, $logger объявлены с модификатором public, это нарушает принцип открытости/закрытости. Также типы данных не описаны через phpdoc.

У метода getResponse унаследована документация, хотя метод отсутствует в родительском классе.
Если в качестве работы с кешем использовались классы отсюда https://github.com/php-fig/cache то имеет смысл ловить только исключения \Psr\Cache\InvalidArgumentException.

И метод getCacheKey не нужен, потому что получение ключа должно быть реализовано в методе getKey() интерфейса CacheItemInterface. Соотвественно, необходимо создать класс, описывающий CacheItemInterface и в нем реализовать getKey.
Также нет фиксации значения в кеше через вызов $this->cache->save($cacheItem). И как следствие нет проверки на то что с кешем что-то не так при сохранении.

Также в блоке catch при записи в лог нет никакой информации об ошибке. В дебаг режиме имеет смысл передавать всю информацию по исключению: стек трейс, путь к файлу, номер строки. Плюс если исключение может выбрасывать только метод getItem, то имеет смысл вынести getCacheKey за блок try и также передавать его в логер.

Логер в данной реализации можно забыть передать в класс (метод getResponse вызвать позже чем setLogger или вообще его не вызвать), что приведет к падению приложения в случае выброса исключения и попытки обращения к методу свойства $this->logger. Нужно также передавать в конструктор, либо проверять перед обращением на соответствие через instanceof.
return []; в конце метода в случае выброса исключения выглядит как затычка, вводящая в заблуждение (снаружи представляется что это и есть ответ от сервиса)

Вопрос со strict_types также открыт
